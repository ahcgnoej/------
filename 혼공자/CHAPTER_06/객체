-----
객체
-> 배열은 요소에 접근할 때 인덱스를 사용하지만, 객체는 키를 사용
-> 객체는 중괄호{...}로 생성하며, 다음과 같은 형태의 자료를 쉼표로 연결해서 입력
-> 키:값

const product={
  제품명 : '7D 건조 망고',
  유형 : '당절임',
  성분 : '망고, 설탕, 치자황색소',
  원산지 : '필리핀'
}

-> 객체 요소에 접근하기 : 대괄호 [] 사용
  > product['제품명'] //'7D 건조 망고'
  > 식별자가 아닌 문자열을 키로 사용했을 때는 무조건 대괄호를 사용해야 객체의 요소에 접근 가능 

-> 객체 요소에 접근하기 : 온점 . 사용 
  > product.제품명 //'7D 건조 망고'

-----
속성과 메소드

-> 객체의 속성은 모든 형태의 자료값을 가질 수 있음 

-> 속성과 메소드 구분하기
  > 메소드 : 객체의 속성 중 함수 자료형인 속성 
  const pet = {
    name : '구름',
    eat : function(food){}
  }
  person.eat() // 메소드 호출 

-> 메소드 내부에서 this 키워드 사용하기
  > 자기 자신의 자신이 가진 속성이라는 것을 표시할 때 this 키워드를 사용
  const pet = {
    name: '구름',
    eat : function(food){
      alert(this.name+'은/는'+food+'을/를 먹습니다')
    }
  }
  pet.eat('밥')

-> 동적으로 객체 속성 추가/제거
  > 동적으로 객체 속성 추가 
    const student= {}
    student.이름 = '채정'
    student.취미 = '개발'
    student.장래희망 = '개발자'
    console.log(JSON.stringify(student,null,2))
    //JSON.stringify 함수
    //javascript 객체를 JSON 문자열로 변한한다. 이 함수는 세가지 인수를 받는다 
    //JSON.stringify(변환할객체,리플레이서 함수 또는 배열,들여쓰기 칸 수)
    //왜 사용하는가? 1) 가독성 : 가독성을 높임 2) 콘솔에 객체를 읽기 쉽게 출력할 수 있어 디버깅할 때 유용 
  > 동적으로 객체 속성 제거
    > delete 키워드 사용
    > delete 객체.속성  
    delete student.장래희망

-----
객체의 속성과 메소드 사용하기

-> 객체 자료형 
  > 속성과 메소드를 가질 수 있는 모든 것은 객체이다. (배열, 함수 모두 객체)
  > Array.isArray() 메소드를 사용해서 배열인지 아닌지 구분할 수 있다. 
  const a = []; a.sample = 10; 하면 a배열에 sample : 10이 추가된다. typeof a를 하면 'object'가 출력되는 것으로 보아 객체임을 알 수 있다. a=[]; b={};모두 객체지만 b는 배열이 아니다. Array.isArray(b)하면 false가 출력된다. 

-> indexOf() 메소드
  > const hi  = '안녕하세요'; hi.indexOf('안녕'); hi.indexOf('하세요'); he.indexOf('없음') //0 1 -1

-> Number 객체 
  > toFixed() 메소드로 숫자 N번째 자릿수까지 출력하기 
  const num= 123.456789; num.toFixed(3); //123.457 

-> String 객체 
  > trim() 메소드로 문자열 양쪽 끝의 공백 없애기 
  const stirngA = '   hi   '; stringA.trim() //'hi'
  > split() 메소드로 문자열을 특정 기호로 자르기, 매개변수로 잘라서 배열을 만들어 리턴
  const stringA = "as \n sfcfec \n csc" // ['as','sfcfec','csc'] 

-> JSON 객체
  > 인터넷에서 문자열로 데이터를 주고 받을 때는 CSV,XML,CSON 등의 다양한 자료 표현 방식을 사용. 현재 가장 많이 사용되는 자료 표현 방식은 JSON 객체.
  > 값을 표현할 때는 문자열, 숫자, 불 자료형만 사용할 수 있다. (함수 사용 불가)
  > 문자열은 반드시 큰따옴표로 붙여야 함 
  > 키에도 반드시 따옴표 붙여야 함 
  {"name":"혼자 공부하는 파이썬" , "price":18000 , "publisher":"한빛미디어"}
  > javascript객체와 JSON객체를 비교하면 JSON 객체에서는 key값에 꼭 따옴표를 써야한다는 차이점이 있다. JSON은 데이터 교환 형식으로, 키와 값 모두 반드시 따옴표를 사용해야 한다. 자바스크립트뿐만 아니라 다른 언어에서도 사용할 수 있는 공통된 형식으로 규칙이 엄격하다. 

-> Math 객체
  > Math.ranom() 메소드
  const num= Math.random(); 
  console.log(num*10) //0-10사이의 랜덤한 숫자
  console.log(Math.floor(num*10)) // 0-10사이의 랜덤한 정수 

-----
객체와 배열 고급 

-> 배열 기반의 다중 할당
  > 최신 자바스크립트부터 배열과 비슷한 작성 방법으로 한 번에 여러 개의 변수에 값을 할당하는 다중 할당 기능이 추가 
  > 할당 연산자 (=) 왼쪽에 식별자(변수 또는 상수)의 배열을 넣고, 오른쪽에 배열을 위치시키면 배열의 위치에 맞게 값들이 할당
  let [a,b] = [1,2] //a는 1이되고 b는 2가 됨
  let [a,b,c] = [1,2,3,4,5] // a,b,c까지 차례대로 1,2,3이 대입되고 4,5는 버려짐 
  > 배열의 크기는 같을 필요도 없고 const 키워드로도 사용할 수 있음 

-> 객체 기반의 다중 할당 
  > 최신 자바스크립트에서는 객체 내부에 있는 속성을 꺼내서 변수로 할당할 때 다음과 같이 사용 가능
  > {속성이름, 속성이름} = 객체 또는 {식별자 = 속성이름, 식별자 = 속성이름} = 객체 
  const object = {
    name : '혼공자',
    price : 18000,
    publisher : '한빛미디어',
  }
  const {name,price} = object;
  console.log(name, price) //혼자 공부하는 파이썬 18000 
  const {a=name,b=price} = object;
  console.log(a, b) //혼자 공부하는 파이썬 18000 

-> 배열 전개 연산자 
  > 얕은복사 
    > 배열은 복사해도 다른 이름이 붙을 뿐, 같은 요소를 가지고 있다. 
    const 물건1 = ['우유','식빵'] 
    const 물건2 = 물건1
    물건2.push('토마토')
    console.log(물건1) // ['우유','식빵','토마토']
  > 깊은 복사
    > 복사한 두 배열이 완전히 독립적으로 작동한다. 자바스크립트 개발에서는 클론을 만드는 것이라고 표현하기도 한다. 
    > 전개 연산자를 사용한다
    const 물건1 = ['우유','식빵'] 
    const 물건2 = [...물건1]
    물건2.push('토마토')
    console.log(물건1) // ['우유','식빵']
    > 복사한 뒤에 자료를 추가하는 코드도 많이 사용된다. 
    const 물건2 = ['고구마',...물건1,'토마토'] // 물건1 = '고구마','우유','식빵','토마토' 

-> 객체 전개 연산자 
  > 얕은 복사
  const 구름 = {
      이름 : '구름',
      나이 : 6,
      종족 : '강아지'
    }
    const 별 = 구름
    별.이름 = '별'
    별.나이 = 1
    console.log(JSON.stringify(구름)) // {'이름' : '별', '나이': '1', '종족': '강아지'}
    console.log(JSON.stringify(별)) // {'이름' : '별', '나이': '1', '종족': '강아지'}
  > 깊은 복사
    > 객체도 깊은 복사를 할 때 전개 연산자를 사용한다. 
    const 구름 = {
      이름 : '구름',
      나이 : 6,
      종족 : '강아지'
    }
    const 별 = {...구름}
    별.이름 = '별'
    별.나이 = 1
    console.log(JSON.stringify(구름)) // {'이름' : '구름', '나이': '6', '종족': '강아지'}
    console.log(JSON.stringify(별)) // {'이름' : '별', '나이': '1', '종족': '강아지'}