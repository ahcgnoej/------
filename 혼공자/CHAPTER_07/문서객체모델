-----
문서 객체 모델

-> 문서 객체 가져오기
  > document.body코드를 사용하여 문서의 body 요소 읽기
    > document.head / document.title 등등도 가능 
  > head 요소와 body 요소 내부에 만든 다른 요소들은 다음과 같은 별도의 메소드를 사용한다. 
    > document.querySelector(선택자)
    > document.querySelectorAll(선택자)
    > 선택자 종류에 따라 선택자 형태가 다르다 
      > 태그 선택자 -> 태그
      > 아이디 선택자 -> #아이디
      > 클래스 선택자 -> .클래스
      > 속성 선택자 -> [속성=값]
      > 후손 선택자 -> 선택자A 선택자B (선택자A 아래에 있는 선택자B를 선택)

-> 글자 조작하기
  > 문서객체.textContent -> 입력된 문자열을 그대로 기입
  > 문서객체.innerHTML -> 입력된 문자열을 HTML 형식으로 기입 

-> 속성 조작하기 
  > 문서객체.setAttribute(속성이름,값) -> 특정 속성에 값을 지정
  > 문서객체.getAttribute(속성이름) -> 특정 속성을 추출

-> 스타일 조작하기 
  > h1.style.backgroundColor 이런식으로 사용 

-> 문서 객체 생성 
  > document.createElement(문서객체이름) 메소드 사용 
  > 문서를 어떤 문서 아래에 추가할지를 지정 -> 부모객체.appendChild(자식객체)
    > 이 appendChild 객체는 문서 객체를 이동할 때도 사용한다.   

-> 문서 객체 제거 
  > 부모객체.removeChild(자식객체)
  > appendChild() 메소드 등으로 부모 객체와 이미 연결이 완료된 문서 객체의 경우 parentNode 속성으로 부모 객체에 접근할 수 있으므로 일반적으로 어떤 문서 객체를 제거할 때는 다음과 같은 형태의 코드를 사용
    > 문서객체.parentNode.removeChild(문서객체)

-> 이벤트 설정하기
  > addEventListener() 메소드 
    > 문서객체.addEventListener(이벤트이름, 콜백함수)
  > removeEventListener() 메소드
    > 

-> DOMContentLoaded 이벤트
  > DOMContentLoaded 이벤트는 웹 브라우저가 문서 객체를 모두 읽고 나서 실핻하는 이벤트이다. 
  document.addEventListener('DOMContentLoaded',()=>{
    const h1=(text)=><h1>${text}</h1>
    document.body.innerHTML+=h1('DOMContentLoaded 이벤트 발생')
  })
  > 돔트리 분석이 끝나면 발생한다. 즉, 돔트리가 다 만들어진 후에 돔에 접근이 가능하기 때문에 돔이 생성되기 전 돔을 조작하는 자바스크립트 코드가 실행되어 원하지 않는 결과를 내는 것을 막을 수 있다. 
  > 웹 문서를 만들때, '문서가 로드되는 시점'에 발생하는 이벤트로 줄 DOMContentLoaded와 onload를 사용한다. onload는 문서의 모든 콘텐츠 (images, script, css, etc)가 로드되었을 때 실행되며 DOMContentLoaded는 DOM트리를 완성하는 즉시 발생한다. onload는 window.onload=function(){} 이런식으로 사용 아니면 window.addEventListener('load',functioln(){})도 가능 
  > 그렇다면 저 DOMContentLoaded를 왜 사용하나??
    > DOM이 모두 로딩되지 않았을 때는 Element가 아직 없을 수 없기 때문이다. js 코드가 로딩 전에 작동해서 없는 Element를 querySelector로 찾으면 null이 나와서 null.addEventListener(...)에서 오류가 발생할 수도 있다. 
    > 다른 방법으로는 HTML은 위에서부터 순차적으로 파싱하는 특징을 이용해 사용하는 Element 하단에 script를 써주면 null이 발생할 문제를 피할 순 있다. 